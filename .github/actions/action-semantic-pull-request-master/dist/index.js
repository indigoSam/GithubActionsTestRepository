(()=>{var __webpack_modules__={980:e=>{const t=/[,\s]\s*/;e.exports={parseEnum(e){return e.split(t).map((e=>e.trim())).filter((e=>e.length>0))},parseBoolean(e){return JSON.parse(e.trim())},parseString(e){return e}}},347:e=>{e.exports=function formatMessage(e,t){let r=e;if(t){Object.entries(t).forEach((([e,t])=>{r=r.replace(new RegExp(`{${e}}`,"g"),t)}))}return r}},336:(e,t,r)=>{const s=r(518);const o=r(832);const n=r(918);const i=r(311);e.exports=async function run(){try{const{types:e,scopes:t,requireScope:r,wip:s,subjectPattern:a,subjectPatternError:c,validateSingleCommit:l,validateSingleCommitMatchesPrTitle:p,githubBaseUrl:u}=n();const m=o.getOctokit(process.env.GITHUB_TOKEN,{baseUrl:u});const _=o.context.payload.pull_request;if(!_){throw new Error("This action can only be invoked in `pull_request_target` or `pull_request` events. Otherwise the pull request can't be inferred.")}const h=_.base.user.login;const f=_.base.repo.name;const{data:d}=await m.rest.pulls.get({owner:h,repo:f,pull_number:_.number});const b=s&&/^\[WIP\]\s/.test(d.title);let w;if(!b){try{await i(d.title,{types:e,scopes:t,requireScope:r,subjectPattern:a,subjectPatternError:c});if(l){const s=[];let o=[];for await(const e of m.paginate.iterator(m.rest.pulls.listCommits,{owner:h,repo:f,pull_number:_.number})){s.push(...e.data);o=s.filter((e=>e.parents.length<2));if(o.length>=2)break}if(o.length===1){try{await i(o[0].commit.message,{types:e,scopes:t,requireScope:r,subjectPattern:a,subjectPatternError:c})}catch(e){throw new Error(`Pull request has only one commit and it's not semantic; this may lead to a non-semantic commit in the base branch (see https://github.community/t/how-to-change-the-default-squash-merge-commit-message/1155). Amend the commit message to match the pull request title, or add another commit.`)}if(p){const e=o[0].commit.message.split("\n")[0];if(e!==d.title){throw new Error(`The pull request has only one (non-merge) commit and in this case Github will use it as the default commit message when merging. The pull request title doesn't match the commit though ("${d.title}" vs. "${e}"). Please update the pull request title accordingly to avoid surprises.`)}}}}}catch(e){w=e}}if(s){const e=b||w!=null?"pending":"success";await m.request("POST /repos/:owner/:repo/statuses/:sha",{owner:h,repo:f,sha:d.head.sha,state:e,target_url:"https://github.com/amannn/action-semantic-pull-request",description:b?'This PR is marked with "[WIP]".':w?"PR title validation failed":"Ready for review & merge.",context:"action-semantic-pull-request"})}if(!b&&w){throw w}}catch(e){s.setFailed(e.message)}}},918:(e,t,r)=>{const s=r(980);e.exports=function parseConfig(){let e;if(process.env.INPUT_TYPES){e=s.parseEnum(process.env.INPUT_TYPES)}let t;if(process.env.INPUT_SCOPES){t=s.parseEnum(process.env.INPUT_SCOPES)}let r;if(process.env.INPUT_REQUIRESCOPE){r=s.parseBoolean(process.env.INPUT_REQUIRESCOPE)}let o;if(process.env.INPUT_SUBJECTPATTERN){o=s.parseString(process.env.INPUT_SUBJECTPATTERN)}let n;if(process.env.INPUT_SUBJECTPATTERNERROR){n=s.parseString(process.env.INPUT_SUBJECTPATTERNERROR)}let i;if(process.env.INPUT_WIP){i=s.parseBoolean(process.env.INPUT_WIP)}let a;if(process.env.INPUT_VALIDATESINGLECOMMIT){a=s.parseBoolean(process.env.INPUT_VALIDATESINGLECOMMIT)}let c;if(process.env.INPUT_VALIDATESINGLECOMMITMATCHESPRTITLE){c=s.parseBoolean(process.env.INPUT_VALIDATESINGLECOMMITMATCHESPRTITLE)}let l;if(process.env.INPUT_GITHUBBASEURL){l=s.parseString(process.env.INPUT_GITHUBBASEURL)}return{types:e,scopes:t,requireScope:r,wip:i,subjectPattern:o,subjectPatternError:n,validateSingleCommit:a,validateSingleCommitMatchesPrTitle:c,githubBaseUrl:l}}},311:(e,t,r)=>{const s=r(759);const o=r(86);const n=r(426).sync;const i=r(347);const a=Object.keys(o.types);e.exports=async function validatePrTitle(e,{types:t,scopes:r,requireScope:c,subjectPattern:l,subjectPatternError:p}={}){if(!t)t=a;const{parserOpts:u}=await s();const m=n(e,u);function printAvailableTypes(){return`Available types:\n${t.map((e=>{let r=` - ${e}`;if(t===a){r+=`: ${o.types[e].description}`}return r})).join("\n")}`}function isUnknownScope(e){return r&&!r.includes(e)}if(!m.type){throw new Error(`No release type found in pull request title "${e}". Add a prefix to indicate what kind of release this pull request corresponds to. For reference, see https://www.conventionalcommits.org/\n\n${printAvailableTypes()}`)}if(!m.subject){throw new Error(`No subject found in pull request title "${e}".`)}if(!t.includes(m.type)){throw new Error(`Unknown release type "${m.type}" found in pull request title "${e}". \n\n${printAvailableTypes()}`)}if(c&&!m.scope){let t=`No scope found in pull request title "${e}".`;if(r){t+=` Use one of the available scopes: ${r.join(", ")}.`}throw new Error(t)}const _=m.scope?m.scope.split(",").map((e=>e.trim())):undefined;const h=_?_.filter(isUnknownScope):[];if(r&&h.length>0){throw new Error(`Unknown ${h.length>1?"scopes":"scope"} "${h.join(",")}" found in pull request title "${e}". Use one of the available scopes: ${r.join(", ")}.`)}function throwSubjectPatternError(t){if(p){t=i(p,{subject:m.subject,title:e})}throw new Error(t)}if(l){const t=m.subject.match(new RegExp(l));if(!t){throwSubjectPatternError(`The subject "${m.subject}" found in pull request title "${e}" doesn't match the configured pattern "${l}".`)}const r=t[0];if(r.length!==m.subject.length){throwSubjectPatternError(`The subject "${m.subject}" found in pull request title "${e}" isn't an exact match for the configured pattern "${l}". Please provide a subject that matches the whole pattern exactly.`)}}}},518:module=>{module.exports=eval("require")("@actions/core")},832:module=>{module.exports=eval("require")("@actions/github")},759:module=>{module.exports=eval("require")("conventional-changelog-conventionalcommits")},86:module=>{module.exports=eval("require")("conventional-commit-types")},426:module=>{module.exports=eval("require")("conventional-commits-parser")}};var __webpack_module_cache__={};function __nccwpck_require__(e){var t=__webpack_module_cache__[e];if(t!==undefined){return t.exports}var r=__webpack_module_cache__[e]={exports:{}};var s=true;try{__webpack_modules__[e](r,r.exports,__nccwpck_require__);s=false}finally{if(s)delete __webpack_module_cache__[e]}return r.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var __webpack_exports__={};(()=>{const e=__nccwpck_require__(336);e()})();module.exports=__webpack_exports__})();